

import os
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Text, Numeric, Boolean, ForeignKey, DateTime, JSON, Index
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import declarative_base, relationship
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import dotenv

dotenv.load_dotenv()

Base = declarative_base()


class Partner(Base):
    """
    E-commerce partners (Noon, Jumbo, Sharaf DG, etc.)
    Stores information about each retail partner
    """
    __tablename__ = "partners"

    partner_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    company_name = Column(String(255), nullable=False, index=True)
    website_url = Column(String(500), nullable=False)
    country = Column(String(10), nullable=False, index=True)
    status = Column(String(50), default="pending", index=True)
    created_at = Column(DateTime, default=datetime.utcnow, index=True)

    # Relationships
    products = relationship("Product", back_populates="partner", cascade="all, delete-orphan")
    packages = relationship("InsurancePackage", back_populates="partner", cascade="all, delete-orphan")

    def __repr__(self):
        return f"<Partner(id={self.partner_id}, name={self.company_name}, country={self.country})>"


class Product(Base):
    """
    Scraped products from e-commerce sites
    Stores product information and processing status for AI workflow
    """
    __tablename__ = "products"

    product_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    partner_id = Column(UUID(as_uuid=True), ForeignKey("partners.partner_id", ondelete="CASCADE"), nullable=False)
    
    # Product information
    product_name = Column(String(500), nullable=False, index=True)
    description = Column(Text)
    category = Column(String(255), index=True)
    brand = Column(String(255), index=True)
    price = Column(Numeric(10, 2), nullable=False, default=0.0, index=True)
    currency = Column(String(10), nullable=False, index=True)
    product_url = Column(Text)
    image_url = Column(Text)
    source_website = Column(String(255))
    in_stock = Column(Boolean, default=True)
    scraped_at = Column(DateTime, default=datetime.utcnow, index=True)
    
   
    # These fields track the AI processing workflow
    
    processed = Column(Boolean, default=False, index=True)
    # True = AI has processed this product
    # False = Not yet processed
    
    processing_status = Column(String(50), default='pending', index=True)
    # Status values:
    #   - 'pending': Waiting to be processed
    #   - 'processing': Currently being processed by AI
    #   - 'completed': Successfully processed
    #   - 'failed': Processing failed with error
    
    processing_started_at = Column(DateTime, nullable=True)
    # Timestamp when AI processing started
    
    processing_completed_at = Column(DateTime, nullable=True)
    # Timestamp when AI processing finished (success or failure)
    
    processing_error = Column(Text, nullable=True)
    # Error message if processing failed
    
    # Relationships
    partner = relationship("Partner", back_populates="products")
    insurance_package = relationship("InsurancePackage", back_populates="product", uselist=False)

    # Composite indexes for common queries
    __table_args__ = (
        Index('idx_partner_processed', 'partner_id', 'processed'),
        Index('idx_partner_status', 'partner_id', 'processing_status'),
    )

    def __repr__(self):
        return f"<Product(id={self.product_id}, name={self.product_name[:30]}..., price={self.price} {self.currency}, status={self.processing_status})>"


class InsurancePackage(Base):
    """
    AI-generated insurance packages for products
    Stores the complete insurance quote generated by the AI agent
    """
    __tablename__ = "insurance_packages"

    package_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    partner_id = Column(UUID(as_uuid=True), ForeignKey("partners.partner_id", ondelete="CASCADE"), nullable=False)
    product_id = Column(UUID(as_uuid=True), ForeignKey("products.product_id", ondelete="CASCADE"), nullable=False, unique=True)
    
    # Insurance package data (complete JSON response from AI)
    package_data = Column(JSON, nullable=False)
    # Contains:
    #   - product: {name, brand, category, price, currency, description}
    #   - eligible: true/false
    #   - risk_profile: "ELECTRONIC_PRODUCTS", "OPULENCIA_PREMIUM", etc.
    #   - document_type: "STANDARD", "ASSURMAX", "OPULENCIA"
    #   - plans: {...} or premium: {...}
    #   - coverage_modules: [...]
    #   - exclusions: [...]
    
    status = Column(String(50), default="ai_generated", index=True)
    # Status values:
    #   - 'eligible': Product is eligible for insurance
    #   - 'not_eligible': Product is not eligible
    #   - 'ai_generated': Package generated by AI (default)
    
    ai_confidence = Column(Numeric(3, 2), default=0.95)
    # AI confidence score (0.00 to 1.00)
    # 0.95 = eligible products
    # 0.00 = not eligible products
    
    created_at = Column(DateTime, default=datetime.utcnow, index=True)

    # Relationships
    partner = relationship("Partner", back_populates="packages")
    product = relationship("Product", back_populates="insurance_package")

    def __repr__(self):
        return f"<InsurancePackage(id={self.package_id}, product_id={self.product_id}, status={self.status})>"


# ============================================================
# DATABASE CONNECTION SETUP
# ============================================================

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL not set in .env file")

# Create engine with connection pooling
engine = create_engine(
    DATABASE_URL,
    pool_size=10,           # Number of persistent connections
    max_overflow=20,        # Additional connections when pool is full
    pool_pre_ping=True,     # Test connections before using
    echo=False              # Set to True for SQL query logging
)

# Session factory for creating database sessions
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create all tables (if they don't exist)
Base.metadata.create_all(bind=engine)


# ============================================================
# HELPER FUNCTIONS
# ============================================================

def get_db():
    """
    Get database session (for dependency injection in FastAPI)
    
    Usage:
        from database.models import get_db
        
        def my_function(db: Session = Depends(get_db)):
            products = db.query(Product).all()
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def get_db_session():
    """
    Get database session (for direct use in scripts)
    
    Usage:
        from database.models import get_db_session
        
        db = get_db_session()
        try:
            products = db.query(Product).all()
        finally:
            db.close()
    """
    return SessionLocal()
